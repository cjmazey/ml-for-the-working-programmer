#+STARTUP: indent
#+OPTIONS: num:nil
* Chapter 3

Lists

** Exercise 3.1

   #+BEGIN_SRC sml
     fun maxl ns =
        if null ns
           then raise Empty
        else let val n = hd ns
                 val ns' = tl ns
             in
                if null ns'
                   then n
                else let val n' = hd ns'
                         val ns'' = tl ns'
                     in
                        if n < n'
                           then maxl (n' :: ns'')
                        else maxl (n :: ns'')
                     end
             end
   #+END_SRC

   #+RESULTS:
   : val maxl = fn : int list -> int

** Exercise 3.2

   #+BEGIN_SRC sml
     val rec last =
        fn [] => raise Empty
         | [x] => x
         | _ :: xs => last xs
   #+END_SRC

   #+RESULTS:
   : val last = fn : 'a list -> 'a

** Exercise 3.3

=take= returns the whole list on the former, the empty list on the
latter.

=drop= returns the empty list on the former, the whole list on the
latter.

#+BEGIN_SRC sml
  fun take ([], _) = []
    | take (x :: xs, i) = if i > 0
                             then x :: take (xs, i - 1)
                          else []

  fun drop ([], _) = []
    | drop (x :: xs, i) = if i > 0
                             then drop (xs, i - 1)
                          else x :: xs

  fun test () = let val l = [1, 2, 3]
                in
                   (take (l, 4),
                    take (l, ~1),
                    drop (l, 4),
                    drop (l, ~1))
                end
#+END_SRC

#+RESULTS:
: val take = fn : 'a list * int -> 'a list
: val drop = fn : 'a list * int -> 'a list
: val test = fn : unit -> int list * int list * int list * int list

** Exercise 3.4

#+BEGIN_SRC sml
  val rec nth =
     fn ([], _) => raise Empty
      | (x :: _, 0) => x
      | (_ :: xs, n) => nth (xs, n - 1)
#+END_SRC

#+RESULTS:
: val nth = fn : 'a list * int -> 'a

** Exercise 3.5

#+BEGIN_SRC sml
  infixr 5 @

  fun ([] @ ys) = ys
    | (xs @ []) = xs
    | ((x :: xs) @ ys) = x :: (xs @ ys)
#+END_SRC

#+RESULTS:
: infixr 5 @
: val @ = fn : 'a list * 'a list -> 'a list

** Exercise 3.6

Then =x= must be a list, and =nrev xs= must be the same kind of list,
and =nrev= takes a list of such lists as its argument, i.e.

=nrev: 'a list list -> 'a list=

and

=nrev [[1,2,3],[4,5,6],[7]]= ==> =[7,4,5,6,1,2,3]=.

#+BEGIN_SRC sml
  fun nrev' [] = []
    | nrev' (x :: xs) = (nrev' xs) @ x
#+END_SRC

#+RESULTS:
: val nrev' = fn : 'a list list -> 'a list

** Exercise 3.7

#+BEGIN_SRC sml
  structure Expr =
     struct

        exception ToList

        datatype expr =
           Enil
         | Econs of int * expr
         | Econs' of int * expr   (* evaluated Econs *)
         | Eapp of expr * expr
         | Enrev of expr
         | ErevAppend of expr * expr
         | Erev of expr

        fun toList Enil = []
          | toList (Econs' (x, xs)) = x :: toList xs
          | toList _ = raise ToList

        val fromList = foldr Econs' Enil

        fun isValue e =
           case e of
              Enil => true
            | Econs' _ => true
            | _ => false

        fun toString l =
           case l of
              Enil => "[]"
            | Econs (x, xs) => concat [Int.toString x,
                                       " :: (",
                                       toString xs,
                                       ")"]
            | Econs' _ => concat ["[",
                                  String.concatWith ","
                                                    (map Int.toString
                                                         (toList l)),
                                  "]"]
            | Eapp (xs, ys) => concat ["(",
                                       toString xs,
                                       ") @ (",
                                       toString ys,
                                       ")"]
            | Enrev xs => concat ["nrev (",
                                  toString xs,
                                  ")"]
            | ErevAppend (xs, ys) => concat ["revAppend (",
                                             toString xs,
                                             ", ",
                                             toString ys,
                                             ")"]
            | Erev xs => concat ["rev (",
                                 toString xs,
                                 ")"]

        fun step e =
           case e of
              Enil => e
            | Econs (x, xs) => if isValue xs
                                  then Econs' (x, xs)
                               else Econs (x, step xs)
            | Econs' _ => e
            | Eapp (Enil, ys) => if isValue ys
                                    then ys
                                 else Eapp (Enil, step ys)
            | Eapp (u as Econs' (x, xs), ys) =>
                 if isValue ys
                    then Econs (x, Eapp (xs, ys))
                 else Eapp (u, step ys)
            | Eapp (xs, ys) => Eapp (step xs, ys)
            | Enrev Enil => Enil
            | Enrev (u as Econs' (x, xs)) =>
                 Eapp (Enrev xs, Econs (x, Enil))
            | Enrev xs => Enrev (step xs)
            | ErevAppend (Enil, ys) => if isValue ys
                                          then ys
                                       else ErevAppend (Enil, step ys)
            | ErevAppend (u as Econs' (x, xs), ys) =>
                 if isValue ys
                    then ErevAppend (xs, Econs (x, ys))
                 else ErevAppend (u, step ys)
            | ErevAppend (xs, ys) => ErevAppend (step xs, ys)
            | Erev xs => if isValue xs
                            then ErevAppend (xs, Enil)
                         else Erev (step xs)

        fun stepN e n = if n < 1 then e else stepN (step e) (n - 1)

        fun run e n =
          (String.concatWith " ==>\n"
                             (map toString
                                  (List.tabulate (n, (stepN e))))) ^ "\n"

        fun test () =
          let val foo = fromList [1,2,3,4]
          in
             print "> nrev <\n"
             ; print (run (Enrev foo) 26)
             ; print "\n"
             ; print "> rev <\n"
             ; print (run (Erev foo) 11)
          end

     end
#+END_SRC

#+RESULTS:
#+begin_example
structure Expr :
  sig
    exception ToList
    datatype expr
      = Eapp of expr * expr
      | Econs of int * expr
      | Econs' of int * expr
      | Enil
      | Enrev of expr
      | Erev of expr
      | ErevAppend of expr * expr
    val toList : expr -> int list
    val fromList : int list -> expr
    val isValue : expr -> bool
    val toString : expr -> string
    val step : expr -> expr
    val stepN : expr -> int -> expr
    val run : expr -> int -> string
    val test : unit -> unit
  end
#+end_example

** Exercise 3.8

They both do the same thing, and require about the same number of
steps, but =f= builds up such that it needs space for every element in
every list; while =concat= needs space for all the sublists, it only
works on the elements of each one at a time.  (So =f= potentially
leads to much deeper recursion.)

#+BEGIN_SRC sml
  infixr 5 @
  fun ([] @ ys) = ys
    | ((x :: xs) @ ys)  = x :: (xs @ ys)

  fun concat [] = []
    | concat (l :: ls) = l @ concat ls

  fun f [] = []
    | f ([] :: ls) = f ls
    | f ((x :: l) :: ls) = x :: f (l :: ls)
#+END_SRC

#+RESULTS:
: infixr 5 @
: val @ = fn : 'a list * 'a list -> 'a list
: val concat = fn : 'a list list -> 'a list
: val f = fn : 'a list list -> 'a list

** Exercise 3.9

#+BEGIN_SRC sml
  fun zip ([], _) = []
    | zip (_, []) = []
    | zip (x :: xs, y :: ys) = (x, y) :: zip (xs, ys)
#+END_SRC

#+RESULTS:
: val zip = fn : 'a list * 'b list -> ('a * 'b) list

** Exercise 3.10

=take= builds up recursions as long as the list, but only builds it
once.  =rtake= builds it twice, but iteratively.

#+BEGIN_SRC sml
  fun take ([], i) = []
    | take (x :: xs, i) =
         if i > 0
            then x :: take (xs, i - 1)
         else []

  fun rtake ([], _, taken) = taken
    | rtake (x :: xs, i, taken) =
         if i > 0
            then rtake (xs, i - 1, x :: taken)
         else taken
#+END_SRC

#+RESULTS:
: val take = fn : 'a list * int -> 'a list
: val rtake = fn : 'a list * int * 'a list -> 'a list

** Exercise 3.11

#+BEGIN_SRC sml
  signature ROMAN =
     sig
        exception E
        val fromInt: int -> string
     end

  functor Roman (val d: (int * string) list): ROMAN =
     struct
        exception E

        local val rec loop =
                 fn (0, _, r) => r
                  | (_, [], _) => raise E
                  | (n, d as (v, s) :: d', r) =>
                    if v > n
                       then loop (n, d', r)
                    else loop (n - v, d, r ^ s)
        in
           fun fromInt n = loop (n, d, "")
        end
     end

  structure RomanAdditive =
     Roman (val d = [(1000, "M"),
                     (500, "D"),
                     (100, "C"),
                     (50, "L"),
                     (10, "X"),
                     (5, "V"),
                     (1, "I")])

  structure RomanSubtractive =
     Roman (val d = [(1000, "M"),
                     (900, "CM"),
                     (500, "D"),
                     (400, "CD"),
                     (100, "C"),
                     (90, "XC"),
                     (50, "L"),
                     (40, "XL"),
                     (10, "X"),
                     (9, "IX"),
                     (5, "V"),
                     (4, "IV"),
                     (1, "I")])
#+END_SRC

#+RESULTS:
#+begin_example
signature ROMAN =
  sig
    exception E
    val fromInt : int -> string
  end
functor Roman(<param>: sig val d : (int * string) list end) :
             sig
               exception E
               val fromInt : int -> string
             end
structure RomanAdditive : ROMAN
structure RomanSubtractive : ROMAN
#+end_example

** Exercise 3.12
